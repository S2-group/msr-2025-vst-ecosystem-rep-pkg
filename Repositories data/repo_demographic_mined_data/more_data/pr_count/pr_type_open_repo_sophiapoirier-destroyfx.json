{"total_count": 1, "incomplete_results": false, "items": [{"url": "https://api.github.com/repos/sophiapoirier/destroyfx/issues/63", "repository_url": "https://api.github.com/repos/sophiapoirier/destroyfx", "labels_url": "https://api.github.com/repos/sophiapoirier/destroyfx/issues/63/labels{/name}", "comments_url": "https://api.github.com/repos/sophiapoirier/destroyfx/issues/63/comments", "events_url": "https://api.github.com/repos/sophiapoirier/destroyfx/issues/63/events", "html_url": "https://github.com/sophiapoirier/destroyfx/pull/63", "id": 1144899130, "node_id": "PR_kwDOEZiprs4zLy0W", "number": 63, "title": "Transverb: adapt to \"distance\" changes without crackly glitches", "user": {"login": "sophiapoirier", "id": 2997196, "node_id": "MDQ6VXNlcjI5OTcxOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/2997196?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sophiapoirier", "html_url": "https://github.com/sophiapoirier", "followers_url": "https://api.github.com/users/sophiapoirier/followers", "following_url": "https://api.github.com/users/sophiapoirier/following{/other_user}", "gists_url": "https://api.github.com/users/sophiapoirier/gists{/gist_id}", "starred_url": "https://api.github.com/users/sophiapoirier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sophiapoirier/subscriptions", "organizations_url": "https://api.github.com/users/sophiapoirier/orgs", "repos_url": "https://api.github.com/users/sophiapoirier/repos", "events_url": "https://api.github.com/users/sophiapoirier/events{/privacy}", "received_events_url": "https://api.github.com/users/sophiapoirier/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2022-02-20T02:20:13Z", "updated_at": "2023-07-15T18:03:12Z", "closed_at": null, "author_association": "OWNER", "active_lock_reason": null, "draft": false, "pull_request": {"url": "https://api.github.com/repos/sophiapoirier/destroyfx/pulls/63", "html_url": "https://github.com/sophiapoirier/destroyfx/pull/63", "diff_url": "https://github.com/sophiapoirier/destroyfx/pull/63.diff", "patch_url": "https://github.com/sophiapoirier/destroyfx/pull/63.patch", "merged_at": null}, "body": "Here is my collection of prototypes of different approach to deal with \"distance\" parameter changes in a more sonically interesting manor. My goals are for it to:\r\n1. no longer glitch in an uninteresting way (just sounding like a crummy bug)\r\n2. do something actually interesting/fun sounding instead\r\n\r\nHere there is a new (temporary) parameter for \"distance change mode\" that let's you choose between five algorithms:\r\n\r\n**reverse**\r\nMove playhead in reverse until reaching the new distance.\r\n\r\n**distance varispeed**\r\nIn the buffer, take the period of audio between the current read position to the write position and resample it (stretching or compressing the length as needed) to last the duration of the new \"distance\" setting, and then copy that resampled audio to the delay buffer between the newly distanced read position and the write position.\r\nThe idea inspiring this is the way that analog bucket brigade delays work, where they behave as though they are operating with a fixed storage for the delay audio, and when you lower the delay time, then the same storage is used in full but at a faster rate, so whatever was already in the delay buffer now is pitched higher, but new incoming audio delays at regular speed. And conversely increasing the delay time slows down the existing audio in the delay buffer. for example: (https://www.youtube.com/watch?v=KSaZEqfy0ac&t=1171)\r\n\r\n**buffer varispeed**\r\nLike distance varispeed, but do that transformation to the entire buffer, not just the segment between reader and writer.\r\n\r\n**looping buffer varispeed**\r\nLike buffer varispeed, except that in the case where the distance change is shortening, resampling the entire buffer does not provide enough resampled audio to refill the whole buffer, so keep looping that resampled audio as much as needed for the output to fill the buffer.\r\n\r\n**ad hoc varispeed**\r\nTaking the same resampling rate as used in the previous varispeed modes, rather than rewriting the buffer, offset the active delay head speed with that resampling rate for as long as it takes to reach the target distance.\r\n\r\nI am curious to hear your opinions of these! And I will share mine, plus some other findings:\r\n\r\nI think that reverse really only succeeds at the goal of eliminating glitches, but it isn't that especially fun or interesting sounding.\r\n\r\nI was really happy after implementing distance varispeed, but it was usually glitching at the start of the resampling. I thought that maybe rounding errors for partial sample read positions, or the resampling algorithm that looks back and forward, might not like that new transformation boundary right at the read head, and lead me to implement buffer varispeed. And then looping buffer varispeed as a logical extension.\r\n\r\nThe buffer resampling algorithms are definitely my favorite sounding. They can get pretty enjoyably chaotic and unpredictable as you move the distance parameter around because the buffer resampling compounds on itself, differently in segments of the buffer upon each change. But then I looked at the CPU meter and saw it peaking while dragging the distance slider around. It depends how big your buffer parameter is set in Transverb, and also what the general audio processing buffer size for plugins is in your hold (small Transverb buffer sizes are less of a hit, and larger host buffer sizes make the hit easier to absorb). This also points to the fact that, if you are dragging the parameter around over time, you will get decidedly different audio results depending on what the host buffer size is, which I don't love.\r\n\r\nMuch as I _really_ like the sound I got with these, these problems are pretty major. I thought I could make the update rate for distance parameter changes time-fixed, so that behavior doesn't depend on the host sample rate. That's not too hard, but it doesn't solve the performance problem, even if it means fewer full passes of resampling, those will still be big spikes each time they do happen.\r\n\r\nThen I tried thinking about how to amortize the resampling. This is certainly possible until you start accumulating new distance changes while still playing through a portion of buffer recently resampled from a distance change. It might be possible to simulate that, like build up a map of rates over time or something, but it hurt my brain to solve that problem. If you have ideas as the doctor of mathematics between us, I'm keen to hear!\r\n\r\nAnyway, those serious problems led to ad hoc varispeed mode. I find this one enjoyable and it does address my two goals, but the pitch changes aren't as wild and cumulative, not as fun, but I think it works pretty well.", "reactions": {"url": "https://api.github.com/repos/sophiapoirier/destroyfx/issues/63/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/sophiapoirier/destroyfx/issues/63/timeline", "performed_via_github_app": null, "state_reason": null, "score": 1.0}]}